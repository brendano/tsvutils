#!/usr/bin/env python
"""
Convert a stream of JSON objects to TSV, extracting the keys 
you specify into columns.

If you don't specify any keys, it tries to figure out the set of all keys.
"""
#from __future__ import print_function
import simplejson
#import json as simplejson   # py 3.0
import sys,re,itertools
import tsvutil
tsvutil.fix_stdio()

#all_json = simplejson.load(sys.stdin)
#assert isinstance(all_json, list) and len(all_json)>0
#item1 = json[0]
#keys = items1.keys()
#keys.sort()
#json_iter = all_json

def safe_json_iter(raw_json_iter):
  for raw in raw_json_iter:
    try:
      json = simplejson.loads(raw)
    except Exception, e:
      print>>sys.stderr, type(e), e
    yield json
def take(n, iterable):
  "Return first n items of the iterable as a list"
  return list(itertools.islice(iterable, n))

json_iter = safe_json_iter(sys.stdin)
keys = sys.argv[1:]
if not keys:
  top = take(1000, json_iter)
  keys = set()
  for item in top:  keys |= set(item.keys())
  keys = list(keys); keys.sort()
  json_iter = itertools.chain(top, json_iter)

BAD = re.compile("[\r\n\t]")

def clean_cell(x):
  if x is None: return ""
  return BAD.sub(" ", unicode(x))

def lookup(json, k):
  # return json[k]
  if '.' in k:
    # jpath path
    ks = k.split('.')
    v = json
    for k in ks: v = v.get(k,{})
    return v or ""
  return json.get(k,"")

print "\t".join(keys)
for json in json_iter:
  print "\t".join([clean_cell(lookup(json,k)) for k in keys])
  #print "\t".join([clean_cell(json[k]) for k in keys])
  #print(*[clean_cell(json[k]) for k in keys], sep="\t")

